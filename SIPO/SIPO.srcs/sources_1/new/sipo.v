module sipo (iCLK,
             iRESETn, // 리셋, Active-Low
             iS,      // 1비트 직렬 ??????
             oP);     // 4비트 병렬 출력
    input iCLK, iRESETn;
    input iS; // 직렬 ?????? ?????????
    output [3:0] oP; // 4bit 병렬 출력
    
    d_ff UFF0 (
    .iCLK (iCLK),
    .iCLEARn (iRESETn),
    .iPRESETn (1'b1),
    .iD (iS),
    .oQ (oP[0]));
    
    d_ff UFF1 (
    .iCLK (iCLK),
    .iCLEARn (iRESETn),
    .iPRESETn (1'b1),
    .iD (oP[0]),
    .oQ (oP[1]));
    
    d_ff UFF2 (
    .iCLK (iCLK),
    .iCLEARn (iRESETn),
    .iPRESETn (1'b1),
    .iD (oP[1]),
    .oQ (oP[2]));
    
    d_ff UFF3 (
    .iCLK (iCLK),
    .iCLEARn (iRESETn),
    .iPRESETn (1'b1),
    .iD (oP[2]),
    .oQ (oP[3]));
    
    /*    조건??????????? ????????? sipo ????????? ???????????
     iCLK, // ?????, Active-High
     iRESETn, // 리셋, Active-Low
     iS, // 1비트 직렬 ??????
     oP); // 4비트 병렬 출력
     input iCLK, iRESETn;
     input iS; // 직렬 ?????? ?????????
     output [3:0] oP; // 4bit 병렬 출력
     reg [3:0] p_out; //
     assign oP = p_out;
     always @(posedge iCLK or negedge iRESETn) begin
     p_out <= (!iRESETn) ? 4'b0 : {p_out, iS};
     end
     
     if문을 ????????? sipo ????????? ???????????
     iCLK, // ?????, Active-High
     iRESETn, // 리셋, Active-Low
     iS, // 1비트 직렬 ??????
     oP); // 4비트 병렬 출력
     input iCLK, iRESETn;
     input iS; // 직렬 ?????? ?????????
     output [3:0] oP; // 4bit 병렬 출력
     reg [3:0] p_out; // always ?? ???????? ????? ????????????? reg???????? ??????
     assign oP = p_out;
     always @(posedge iCLK or negedge iRESETn) begin
     if (!iRESETn)
     p_out <= 4'b0;
     else begin
     p_out    <= (p_out << 1);
     p_out[0] <= iS;
     end
     end*/
endmodule
